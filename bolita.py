import json
import re
import sqlite3
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler
from telegram.ext import filters
from datetime import datetime, time
import pytz
import asyncio
from telegram.helpers import mention_html
from necesario import hacer_copia_seguridad, marca_tiempo, comando_basura_user, restaurar_usuario_desde_basura, lock_data, ejecutar_consulta_segura, obtener_registro, actualizar_registro	

DB_FILE = "user_data.db"
CANAL_TICKET = "-1002309255787"
# Constantes
GROUP_CHAT_ID = "-1002128871685"  # Reemplaza con el ID de tu grupo
GROUP_CHAT_ADMIN = "-1002128871685" 

#borrar
async def load_loteria(data):
    async with aiofiles.open(file_path, mode='r') as f:
        contents = await f.read()
        return json.loads(contents)
        
#xxxxxxxxxxbasedatos
# Funci√≥n para guardar jugada en la base de datos
def guardar_jugada_loteria(user_id, nombre_usuario, loteria, jugada, total):
    """Guarda una jugada de loter√≠a en la base de datos"""
    try:
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        
        c.execute("""
            INSERT INTO loterias (user_id, nombre_usuario, loteria, jugada, total)
            VALUES (?, ?, ?, ?, ?)
        """, (user_id, nombre_usuario, loteria, jugada, total))
        
        conn.commit()
        conn.close()
        return True
        
    except Exception as e:
        print(f"Error al guardar jugada de loter√≠a: {e}")
        return False

# Funci√≥n para obtener jugadas de un usuario
def obtener_jugadas_usuario(user_id, loteria=None):
    """Obtiene las jugadas de un usuario, opcionalmente filtradas por loter√≠a"""
    try:
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        
        if loteria:
            c.execute("""
                SELECT loteria, jugada, total, fecha 
                FROM loterias 
                WHERE user_id = ? AND loteria = ?
                ORDER BY fecha DESC
            """, (user_id, loteria))
        else:
            c.execute("""
                SELECT loteria, jugada, total, fecha 
                FROM loterias 
                WHERE user_id = ? 
                ORDER BY fecha DESC
            """, (user_id,))
        
        resultados = c.fetchall()
        conn.close()
        
        return resultados
        
    except Exception as e:
        print(f"Error al obtener jugadas de usuario: {e}")
        return []

# Funci√≥n para obtener resumen de loter√≠as
def obtener_resumen_loterias():
    """Obtiene un resumen de todas las loter√≠as"""
    try:
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        
        # Resumen por loter√≠a
        c.execute("""
            SELECT loteria, SUM(total) as total_loteria, COUNT(*) as cantidad_jugadas
            FROM loterias 
            GROUP BY loteria
            ORDER BY total_loteria DESC
        """)
        
        resumen_loterias = c.fetchall()
        
        # Total general
        c.execute("SELECT SUM(total) FROM loterias")
        total_general = c.fetchone()[0] or 0
        
        conn.close()
        
        return resumen_loterias, total_general
        
    except Exception as e:
        print(f"Error al obtener resumen de loter√≠as: {e}")
        return [], 0

# Funci√≥n para limpiar todas las jugadas
def limpiar_jugadas_loterias():
    """Elimina todas las jugadas de loter√≠a"""
    try:
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        
        c.execute("DELETE FROM loterias")
        conn.commit()
        conn.close()
        
        return True
        
    except Exception as e:
        print(f"Error al limpiar jugadas de loter√≠a: {e}")
        return False
  
      
# Funci√≥n para verificar si la hora actual est√° dentro de un rango
def time_in_range(start, end, current):
    if start <= current <= end:
        return True
    if start > end and (current >= start or current <= end):
        return True
    return False

# Funci√≥n para mostrar el men√∫ de loter√≠as
async def bolita(update, context):
    try:
        user_id = str(update.callback_query.from_user.id) if update.callback_query else str(update.message.from_user.id)
        cuba_tz = pytz.timezone("America/Havana")
        current_time = datetime.now(cuba_tz).time()

        keyboard = []

        # Florida
        if time(8, 30) <= current_time <= time(13, 15):
            keyboard.append([InlineKeyboardButton("üá∫üá∏ Floridaüåû [1:35 PM]", callback_data="üá∫üá∏ Floridaüåû [1:35 PM]")])
        elif time(14, 0) <= current_time <= time(21, 20):
            keyboard.append([InlineKeyboardButton("üá∫üá∏ Floridaüåô [9:50 PM]", callback_data="üá∫üá∏ Floridaüåô [9:50 PM]")])
        elif time(22, 0) <= current_time or current_time <= time(5, 45):
            keyboard.append([InlineKeyboardButton("üá∫üá∏ Floridaüåö [6:00 AM]", callback_data="üá∫üá∏ Floridaüåö [6:00 AM]")])
        else:
            keyboard.append([InlineKeyboardButton("üîê Florida (cerrado)", callback_data="üîê Florida (cerrado)")])

        # Georgia
        if time(8, 30) <= current_time <= time(12, 15):
            keyboard.append([InlineKeyboardButton("üçë Georgiaüåû [12:30 PM]", callback_data="üçë Georgiaüåû [12:30 PM]")])
        elif time(14, 0) <= current_time <= time(18, 45):
            keyboard.append([InlineKeyboardButton("üçë Georgia‚õÖ [7:00 PM]", callback_data="üçë Georgia‚õÖ [7:00 PM]")])
        elif time(19, 30) <= current_time <= time(23, 20):
            keyboard.append([InlineKeyboardButton("üçë Georgiaüåõ [11:35 PM]", callback_data="üçë Georgiaüåõ [11:35 PM]")])
        else:
            keyboard.append([InlineKeyboardButton("üîê Georgia (cerrado)", callback_data="üîê Georgia (cerrado)")])

        # New York
        if time(11, 0) <= current_time <= time(14, 15):
            keyboard.append([InlineKeyboardButton("üóΩ New_Yorküåû [2:30 PM]", callback_data="üóΩ New_Yorküåû [2:30 PM]")])
        elif time(17, 30) <= current_time <= time(22, 15):
            keyboard.append([InlineKeyboardButton("üóΩ New_Yorküåõ [10:30 PM]", callback_data="üóΩ New_Yorküåõ [10:30 PM]")])
        else:
            keyboard.append([InlineKeyboardButton("üîê New_York (cerrado)", callback_data="üîê New_York (cerrado)")])

        # Hait√≠
        if time(11, 0) <= current_time <= time(11, 45):
            keyboard.append([InlineKeyboardButton("üá≠üáπ Hait√≠üåû [12:00 PM]", callback_data="üá≠üáπ Hait√≠üåû [12:00 PM]")])
        elif time(20, 0) <= current_time <= time(20, 45):
            keyboard.append([InlineKeyboardButton("üá≠üáπ Hait√≠üåõ [9:00 PM]", callback_data="üá≠üáπ Hait√≠üåõ [9:00 PM]")])
        else:
            keyboard.append([InlineKeyboardButton("üîê Hait√≠ (cerrado)", callback_data="üîê Hait√≠ (cerrado)")])

        # Miami
        if time(21, 0) <= current_time <= time(21, 45):
            keyboard.append([InlineKeyboardButton("üèôÔ∏è Miamiüåõ [10:00 PM]", callback_data="üèôÔ∏è Miamiüåõ [10:00 PM]")])
        else:
            keyboard.append([InlineKeyboardButton("üîê Miami (cerrado)", callback_data="üîê Miami (cerrado)")])

        keyboard.append([InlineKeyboardButton("üîô Volver", callback_data="menu_principal")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        if update.callback_query:
            await update.callback_query.answer()
            await update.callback_query.message.edit_text("Elige una loter√≠a para jugar:", reply_markup=reply_markup)
        else:
            await update.message.reply_text("Elige una loter√≠a para jugar:", reply_markup=reply_markup)

    except Exception as e:
        print(f"Error en bolita: {e}")
        if update.callback_query:
            await update.callback_query.message.reply_text("Ocurri√≥ un error. Intenta de nuevo.")
        else:
            await update.message.reply_text("Ocurri√≥ un error. Intenta de nuevo.")

# Funci√≥n para seleccionar una loter√≠a
async def seleccionar_loteria(update, context):
    try:
        user_id = str(update.callback_query.from_user.id)
        selected_lottery = update.callback_query.data
        current_time = datetime.now(pytz.timezone("America/Havana")).time()

        lottery_times = {
            "üá∫üá∏ Floridaüåû [1:35 PM]": (time(8, 30), time(13, 35)),
            "üá∫üá∏ Floridaüåô [9:50 PM]": (time(14, 0), time(21, 50)),
            "üá∫üá∏ Floridaüåö [6:00 AM]": (time(22, 0), time(6, 0)),
            "üçë Georgiaüåû [12:30 PM]": (time(8, 30), time(12, 30)),
            "üçë Georgia‚õÖ [7:00 PM]": (time(14, 0), time(19, 0)),
            "üçë Georgiaüåõ [11:35 PM]": (time(20, 0), time(23, 35)),
            "üóΩ New_Yorküåû [2:30 PM]": (time(11, 0), time(14, 30)),
            "üóΩ New_Yorküåõ [10:30 PM]": (time(17, 30), time(22, 30)),
            "üá≠üáπ Hait√≠üåû [12:00 PM]": (time(8, 0), time(12, 0)),
            "üá≠üáπ Hait√≠üåõ [9:00 PM]": (time(19, 0), time(21, 0)),
            "üèôÔ∏è Miamiüåõ [10:00 PM]": (time(20, 30), time(22, 0)),
        }

        if selected_lottery in lottery_times:
            start_time, end_time = lottery_times[selected_lottery]
            if time_in_range(start_time, end_time, current_time):
                context.user_data['estado'] = 'esperando_jugada'
                context.user_data['loteria'] = selected_lottery

                await update.callback_query.answer()
                cancel_button = InlineKeyboardButton("‚ùå Cancelar", callback_data="menu_principal")
                keyboard = InlineKeyboardMarkup([[cancel_button]])

                await update.callback_query.message.reply_text(
                    f"<b>Loteria seleccionada:</b> {selected_lottery}.\n\n"
                    f"Por favor, env√≠ame tu jugada.\n\n"
                    f"‚ö†Ô∏è Debe incluir Total: (total de su jugada) en el mismo mensaje.",
                    parse_mode="HTML",
                    reply_markup=keyboard
                )
            else:
                await update.callback_query.answer()
                await update.callback_query.message.reply_text("üîê La loter√≠a seleccionada est√° cerrada en este momento.")
        else:
            await update.callback_query.answer()
            await update.callback_query.message.reply_text("üîê La loter√≠a seleccionada est√° cerrada en este momento.")

    except Exception as e:
        print(f"Error en seleccionar_loteria: {e}")
        await update.callback_query.message.reply_text("Ocurri√≥ un error. Intenta de nuevo.")


# Funci√≥n para recibir la jugada del usuario
async def recibir_jugada(update, context):
    try:
        if context.user_data is None:
            return
        if context.user_data.get('estado') != 'esperando_jugada':
            return

        loteria_seleccionada = context.user_data.get('loteria')
        if not loteria_seleccionada:
            await update.message.reply_text("üö´ No se ha seleccionado una loter√≠a v√°lida.")
            return

        mensaje = update.message.text.strip()
        match = re.search(r"Total:\s*(\d+)", mensaje)

        if match:
            total = int(match.group(1))
            jugada = mensaje.replace(f"Total: {total}", "").strip()

            context.user_data['total'] = total
            context.user_data['jugada'] = jugada
            context.user_data['estado'] = 'esperando_monto'

            botones = [
                [InlineKeyboardButton("‚úÖ Confirmar", callback_data="procesar_jugada")],
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="bolita")]
            ]
            teclado = InlineKeyboardMarkup(botones)

            fecha_hora_actual = datetime.now().strftime("%d de %B de %Y, %I:%M %p")

            await update.message.reply_text(
                f"<blockquote>üé∞ {loteria_seleccionada.title()}</blockquote>\n\n"
                f"üéØ <b>Jugada:</b>\n {jugada}\n"
                f"üìÖ <b>Fecha:</b> <code>{fecha_hora_actual}</code>\n\n"
                f"üí∞ <b>Total:</b> <code>{total}</code> CUP\n\n"
                "üåü <i>Buena suerte!</i>",
                reply_markup=teclado,
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text("‚ùå No se encontr√≥ un monto total en el mensaje. Aseg√∫rate de incluir 'Total: <monto>'.")

    except Exception as e:
        print(f"Error en recibir_jugada: {e}")
        await update.message.reply_text("‚ö†Ô∏è Ocurri√≥ un error al procesar la jugada. Intenta de nuevo.")

# Funci√≥n para procesar la jugada

async def procesar_jugada(update, context):
    try:
        user_id = str(update.callback_query.from_user.id)
        total = context.user_data.get('total')
        jugada = context.user_data.get('jugada')
        loteria = context.user_data.get('loteria')

        if not total or not jugada or not loteria:
            await update.callback_query.message.reply_text("‚ùå Datos incompletos. Intenta de nuevo.")
            return

        # Obtener datos del usuario desde la base de datos
        usuario_data = obtener_registro("usuarios", user_id, "Nombre, Balance")
        
        if not usuario_data:
            await update.callback_query.message.reply_text("‚ùå No est√°s registrado. Usa /start para registrarte.")
            return

        nombre_usuario, balance_usuario = usuario_data

        if balance_usuario >= total:
            # Actualizar balance del usuario
            exito_balance = actualizar_registro("usuarios", user_id, {
                "Balance": balance_usuario - total
            })
            
            if exito_balance:
                # Guardar jugada en la base de datos
                exito_jugada = guardar_jugada_loteria(user_id, nombre_usuario, loteria, jugada, total)
                
                if exito_jugada:
                    balance_restante = balance_usuario - total
                    
                    keyboard = [[InlineKeyboardButton("üè† Men√∫ Principal", callback_data="menu_principal")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)

                    await update.callback_query.message.reply_text(
                        f"‚úÖ <b>Tu jugada fue procesada correctamente.</b>\n\n"
                        f"üé∞ <b>Loter√≠a:</b> {loteria}\n"
                        f"üéØ <b>Jugada:</b>\n {jugada}\n"
                        f"üí∞ <b>Total descontado:</b> {total} CUP\n"
                        f"üí≥ <b>Balance restante:</b> {balance_restante} CUP",
                        parse_mode="HTML",
                        reply_markup=reply_markup
                    )

                    mensaje_grupo = (
                        f"<blockquote>{loteria}</blockquote> \n"
                        f"<b>üë§ Usuario</b>: {mention_html(user_id, nombre_usuario)}\n"                    
                        f"üéØ <b>Jugada:</b>\n {jugada}\n"
                        f"üí∞ <b>Total:</b> <code>{total}</code> CUP"
                    )

                    await context.bot.send_message(
                        chat_id=CANAL_TICKET,
                        text=mensaje_grupo,
                        parse_mode="HTML"
                    )
                else:
                    await update.callback_query.message.reply_text("‚ùå Error al guardar la jugada.")
            else:
                await update.callback_query.message.reply_text("‚ùå Error al actualizar el balance.")
        else:
            keyboard = [[InlineKeyboardButton("üì• Depositar", callback_data="depositar")]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.message.reply_text(
                f"‚ùå <b>Balance insuficiente</b>, recarga tu cuenta antes de jugar.\n\n"
                f"üèß<b>Balance disponible:</b> {balance_usuario} CUP",
                parse_mode="HTML",
                reply_markup=reply_markup
            )

    except Exception as e:
        print(f"Error al procesar la jugada: {e}")
        await update.callback_query.message.reply_text("‚ö†Ô∏è Ocurri√≥ un error al procesar tu jugada. Intenta de nuevo.")

# Funci√≥n para generar un resumen de las loter√≠as
async def resumen_loterias(update, context):
    try:
        resumen_loterias, total_general = obtener_resumen_loterias()
        
        mensaje = "*üèÜ Resumen de Loter√≠as*\n\n"
        
        for loteria, total_loteria, cantidad_jugadas in resumen_loterias:
            if "Florida" in loteria:
                emoji = "üåû"
            elif "Georgia" in loteria:
                emoji = "üçë"
            elif "New_York" in loteria:
                emoji = "üóΩ"
            else:
                emoji = "üåü"

            mensaje += f"{emoji} *{loteria}:* {total_loteria} CUP ({cantidad_jugadas} jugadas)\n"

        mensaje += f"\n*üí∞ Total en todas las loter√≠as: {total_general} CUP*"
        await update.message.reply_text(mensaje, parse_mode="Markdown")

    except Exception as e:
        print(f"Error al generar el resumen de las loter√≠as: {e}")
        await update.message.reply_text("‚ùå Ocurri√≥ un error al generar el resumen de las loter√≠as.")

# Funci√≥n para refrescar loter√≠as (MODIFICADA)
async def refrescar_loterias(update, context):
    try:
        # Obtener resumen antes de limpiar para enviar como backup
        resumen_loterias, total_general = obtener_resumen_loterias()
        
        # Crear mensaje de backup
        mensaje_backup = "üìä *Resumen de jugadas antes de limpiar:*\n\n"
        for loteria, total_loteria, cantidad_jugadas in resumen_loterias:
            mensaje_backup += f"‚Ä¢ {loteria}: {total_loteria} CUP ({cantidad_jugadas} jugadas)\n"
        mensaje_backup += f"\n*Total general: {total_general} CUP*"
        
        # Enviar backup al grupo de admin
        await context.bot.send_message(
            chat_id=GROUP_CHAT_ADMIN,
            text=mensaje_backup,
            parse_mode="Markdown"
        )
        
        # Limpiar jugadas
        exito = limpiar_jugadas_loterias()
        
        if exito:
            await update.message.reply_text("‚úÖ *Se han borrado todas las jugadas de las loter√≠as.*", parse_mode='Markdown')
        else:
            await update.message.reply_text("‚ùå Error al borrar las jugadas.")

    except Exception as e:
        print(f"Error al refrescar las loter√≠as: {e}")
        await update.message.reply_text("‚ùå Ocurri√≥ un error al intentar borrar las jugadas.")

# Funci√≥n para refrescar las loter√≠as
async def refrescar_loterias(update, context):
    try:
        # Obtener resumen antes de limpiar para enviar como backup
        resumen_loterias, total_general = obtener_resumen_loterias()
        
        # Crear mensaje de backup
        mensaje_backup = "üìä *Resumen de jugadas antes de limpiar:*\n\n"
        for loteria, total_loteria, cantidad_jugadas in resumen_loterias:
            mensaje_backup += f"‚Ä¢ {loteria}: {total_loteria} CUP ({cantidad_jugadas} jugadas)\n"
        mensaje_backup += f"\n*Total general: {total_general} CUP*"
        
        # Enviar backup al grupo de admin
        await context.bot.send_message(
            chat_id=GROUP_CHAT_ADMIN,
            text=mensaje_backup,
            parse_mode="Markdown"
        )
        
        # Limpiar jugadas
        exito = limpiar_jugadas_loterias()
        
        if exito:
            await update.message.reply_text("‚úÖ *Se han borrado todas las jugadas de las loter√≠as.*", parse_mode='Markdown')
        else:
            await update.message.reply_text("‚ùå Error al borrar las jugadas.")

    except Exception as e:
        print(f"Error al refrescar las loter√≠as: {e}")
        await update.message.reply_text("‚ùå Ocurri√≥ un error al intentar borrar las jugadas.")
    

